1、邻接矩阵：

　　直接开一个N×N的二维数组E，然后 E[i][j] 为1的时候表示 i 和 j 之间有一条边，0的时候就没有。

　　这样很方便简单，但是有几个缺陷，首先是效率问题，超过1000个点一般不管是空间还是时间都不允许了。然后就是如果从 3 到 5 有两条边的话，就没法表示了。。。

　　所以一般很少用了现在，当然有些算法还是会用到的。
    int E[110][110];
    E[1][2]=1;
    E[5][3]=0;
    
2、邻接链表：

　　使用链表的方式保存一个结点的所有边，就是每个点都有一个链表。

　　当然写个链表很麻烦，所以一般是用vector来替代。就像是下面这样。
    vector <int> E[110];
    E[3].push_back(6) // 有一条从3到6的边。
  
3、前向星：

    这个名字实在逼格太高，而且很好用效率也高，所以我一直都用这种方式来存图。

　　他和链表几乎没什么区别，就是每次添加新的边的时候往开头加，而不是往最后加。

    具体就像是下面这样：
    struct Edge
    {
        int to,next;
    };

    Edge E[1010];            // 总共不超过1000条边。
    int head[110],Ecou;        // 不超过100个点。

    void init()                // 初始化。
    {
        memset(head,-1,sizeof(head));
        Ecou=0;
    }

    void addEdge(int u,int v)    // 增加边 u，v。
    {
        E[Ecou].to=v;
        E[Ecou].next=head[u];
        head[u]=Ecou++;
    }

